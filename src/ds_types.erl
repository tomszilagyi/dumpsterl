-module(ds_types).
-author("Tom Szilagyi <tomszilagyi@gmail.com>").

-export([ kind/1
        , type_to_string/1
        , attributes/2
        , attribute_to_string/2
        , subtype/2
        , ext_data/1
        , ext_data/3
        ]).

-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-endif.

-include("config.hrl").

-ifdef(CONFIG_MAPS).
-define(is_map(X), is_map(X)).
-else.
-define(is_map(X), false).
-endif.

%% Category, or "kind", of type.
%% Each type belongs to one of three kinds:
%% - abstract: a type which can be broken into subtypes;
%% - generic:  a type which is parameterized by further types.
%%             E.g. a list is really a list of T where T is the type
%%             of all its elements.
%%             Generic types include lists, tuples, records.
%% - leaf:     a leaf type with no further sub-categorization.
%%
%% For abstract types, the node's SubSpec is a list of subtypes;
%% for generic types, SubSpec is a list of type specs that map to
%% the individual type elements. In other words, those are leaf nodes
%% from a strict type hierarchy point of view, since their children
%% belong to another type domain.
kind(nonempty_list) -> generic;
kind(improper_list) -> generic;
kind({tuple, _})    -> generic;
kind({record, _})   -> generic;
kind(_T) -> abstract. %% incomplete for now, but we only really care
%% about the difference between generic and non-generic types.

%% Convert type to a string representing it in a GUI.
type_to_string({record, {RecName, RecSize}}) ->
    io_lib:format("#~s/~B", [RecName, RecSize]);
type_to_string({tuple, Size}) ->
    io_lib:format("tuple/~B", [Size]);
type_to_string(Type) ->
    io_lib:format("~p", [Type]).

%% For generic types, this function returns a list of attributes.
%% The list contains {No, Attribute} tuples, where No is an integer
%% and Attribute is a (possibly empty) string.
%% NB. In case of records, the fields are numbered from 2.
attributes({tuple, N}, _Data) ->
    Ns = lists:seq(1, N),
    lists:zip(Ns, ["" || _F <- Ns]);
attributes({record, {_RecName, RecSize}}, {_Stats, Ext}) ->
    Ns = lists:seq(2, RecSize),
    Attributes =
        case Ext of
            [{Attrs,_Locations}|_] -> [atom_to_list(A) || A <- Attrs];
            [] -> ["" || _F <- Ns]
        end,
    lists:zip(Ns, Attributes);
attributes(nonempty_list,_Data) ->
    [{1, "items"}];
attributes(improper_list,_Data) ->
    [{1, "items"}, {2, "tail"}].

%% Convert attribute to a string representing it in a GUI.
attribute_to_string({record, {RecName,_RecSize}}, {No, Attribute}) ->
    io_lib:format("E~B #~s.~s", [No, RecName, Attribute]);
attribute_to_string({tuple,_Size}, {No,_Attribute}) ->
    io_lib:format("E~B", [No]);
attribute_to_string(_Class, {_No, Attribute}) ->
    Attribute.

%% This should be auto-generated by a 'decision tree compiler'
%% that creates compiled Erlang code from a declarative type
%% hierarchy specification.
%% Compilation should also optimize away the getopt/1 calls,
%% taking a concrete options configuration into account.
subtype([], 'T') -> [];
subtype({}, 'T') -> {};
subtype(V, 'T') when is_number(V) -> number;
subtype(V, 'T') when is_atom(V) -> atom;
subtype(V, 'T') when is_list(V) -> list;
subtype(V, 'T') when is_tuple(V) -> tuple;
subtype(V, 'T') when is_binary(V) -> binary;
subtype(V, 'T') when ?is_map(V) -> map;

subtype(true, atom) -> boolean;
subtype(false, atom) -> boolean;

subtype(N, number) when is_integer(N) -> integer;
subtype(N, number) when is_float(N) -> float;

subtype(I, integer) when I >= 0 -> non_neg_integer;
subtype(I, integer) when I < 0 -> neg_integer;

subtype(0, non_neg_integer) -> 0;
subtype(_I, non_neg_integer) -> pos_integer;
subtype(I, pos_integer) when I =< 16#10ffff -> char;
subtype(I, char) when I =< 255 -> byte;

subtype(L, list) ->
    case is_improper(L) of
        false -> nonempty_list;
        true -> improper_list
    end;

subtype(L, nonempty_list) -> {'$elements', L};
subtype(L, improper_list) -> improper_list(L);

subtype(T, tuple) ->
    case dyn_record(T) of
        {RecName, Size} -> {record, {RecName, Size}};
        false -> {tuple, size(T)}
    end;

subtype(M, map) -> subtype_map(M);

%% compound types where we want to recurse on their elements:
subtype(T, {tuple,_N}) -> {'$fields', tuple_to_list(T)};
subtype(R, {record, {_RecName,_Size}}) -> {'$fields', tl(tuple_to_list(R))};

subtype(_V, _Class) -> '$null'.

%% This is extracted into a separate function for the sake of -ifdef.
-ifdef(CONFIG_MAPS).
subtype_map(_M) -> '$null'. %% TODO
-else.
subtype_map(_M) -> '$null'.
-endif.

%% Find out whether given (nonempty) list is improper or not.
is_improper([]) -> false;
is_improper([_H|T]) -> is_improper(T);
is_improper(_T) -> true.

improper_list(L) -> improper_list(L, []).

improper_list([], _Acc) -> nonempty_list;
improper_list([H|T], Acc) -> improper_list(T, [H|Acc]);
improper_list(T, Acc) -> {'$improper_list', Acc, T}.

%% dynamically classify records; also tagged with size because
%% we can never be sure that a tuple is actually a record.
%% This way, we might tag ordinary tuples as records (if they
%% have an atom as the first element) but will at least always
%% group different types separately.
dyn_record(V) when is_tuple(V) andalso size(V) > 1 ->
    RecName = element(1, V),
    case is_atom(RecName) of
        true  -> {RecName, size(V)};
        false -> false
    end;
dyn_record(_V) -> false.


%% class-specific extra data

%% class-specific initializers
ext_data({record, RecId}) ->
    case ds_records:lookup(RecId) of
        false -> [];
        RAs -> RAs
    end;
ext_data(_Class) -> [].

%% class-specific per-term updaters
ext_data(VA, atom, Ext) -> ext_data_atom(VA, Ext);
ext_data(VA, nonempty_list, Ext) -> ext_data_nonempty_list(VA, Ext);
ext_data(_V,_Class, Ext) -> Ext.


%% For atoms, maintain a dictionary of per-value stats for each value
ext_data_atom({V, Attrs}, Ext) ->
    PVS = case orddict:find(V, Ext) of
              error -> ds_pvattrs:new(Attrs);
              {ok, PVS0} -> ds_pvattrs:add(Attrs, PVS0)
          end,
    orddict:store(V, PVS, Ext).

%% For lists, maintain a histogram of lengths
ext_data_nonempty_list({V,_Attrs}, Ext) ->
    orddict:update_counter(length(V), 1, Ext).

%% Tests
-ifdef(TEST).

-endif.
